Jvm的结构基本上有4部分组成：
类加载器:在JVM启动时或者在类运行时将需要的class加载到jvm中
执行引擎：执行引擎的任务是负责执行class文件中包含的字节码指令，相当于实际机器上的cpu。
内存区：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者PC指针的记录器等
本地方法调用：调用C或者C++实现的本地方法代码返回结果。

JVM内存区域划分：
运行时数据通常包括这几部分:
程序计数器：又称PC寄存器，每个线程都需要有自己独立的程序计数器，并且互不干扰，因为jvm是通过线程切换来进行cpu执行的，也就是说cpu在一个时间点只会执行一条线程中的指令。
堆（heap）：java中的堆是用来存储对象本身的以及数组。堆是被所有线程多共享的，在jvm中只有一个堆。
java栈（stack）：也称为虚拟机栈，java栈是java方法执行的内存模型。Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表、操作数栈、指向当前方法所属的类的运行时常量池的引用、方法地址和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈，当方法执行完成，便会将栈帧出栈。
本地方法区：为执行本地方法服务的。
方法区：与堆一样，是被线程共享的，在方法区中，存储了每个类的信息，包括类的名称，方法信息，字段信息，静态变量，常量以及编译器编译后的代码。在方法区中有一个非常重要的部分就是运行时常量池，他是一个类或者接口的常量池的运行时表示形式，在类和接口被加载到jvm后，对应的运行时常量池就被创建出来。

JVM的工作机制：
当执行一个方法是，计数器会根据存储当前将要执行的指令地址，并且创建一个线程和对应的栈帧，当在第一个方法中调用第二个方法，计数器会记录第二个方法将要执行的指令地址，并且创建一个新的栈帧和线程，当第二个方法执行完毕，计数器会重新记录第一个方法执行的指令位置，继续执行